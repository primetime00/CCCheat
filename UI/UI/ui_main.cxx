// generated by Fast Light User Interface Designer (fluid) version 1.0302

#include "ui_main.h"
rkCheatUI* uiInstance = 0; 

Fl_Menu_Item rkCheatUI::menu_ui_valueType[] = {
 {"1 Byte", 0,  0, (void*)(SEARCH_VALUE_TYPE_1BYTE), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"2 Bytes", 0,  0, (void*)(SEARCH_VALUE_TYPE_2BYTE), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"4 Bytes", 0,  0, (void*)(SEARCH_VALUE_TYPE_4BYTE), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Float", 0,  0, (void*)(SEARCH_VALUE_TYPE_FLOAT), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void rkCheatUI::RangeButtonCB(Fl_Widget *w, void *data) {
  int type = (int)data;
  string fname;
  Fl_Native_File_Chooser fnfc;
  switch (type)
  {
  	case RANGE_SAVE:
  		fnfc.title("Save Ranges");
  		fnfc.type(Fl_Native_File_Chooser::BROWSE_SAVE_FILE);
  		fnfc.filter("Range Files\t*.rng");
  		fnfc.directory("/var/tmp");
  		switch ( fnfc.show() ) {
  		  case -1: printf("ERROR: %s\n", fnfc.errmsg());    break;  // ERROR
  		  case  1: printf("CANCEL\n");                      break;  // CANCEL
  		  default: 
  		  	fname = fnfc.filename();
  		  	if (fnfc.filter_value() == 0)
  		  	{
  				if (fname.find(".rng", fname.size()-4) == string::npos)
  					fname += ".rng";
  			}
  		  	printf("PICKED: %s\n",fname.c_str()); uiInstance->ui_rangeTable->saveData(fname); break;  // FILE CHOSEN
  		}
  		break;
  	case RANGE_LOAD:
  		fnfc.title("Load Ranges");
  		fnfc.type(Fl_Native_File_Chooser::BROWSE_FILE);
  		fnfc.filter("Range Files\t*.rng");
  		fnfc.directory("/var/tmp");
  		switch ( fnfc.show() ) {
  		  case -1: printf("ERROR: %s\n", fnfc.errmsg());    break;  // ERROR
  		  case  1: printf("CANCEL\n");                      break;  // CANCEL
  		  default: 
  		  	fname = fnfc.filename();
  		  	printf("PICKED: %s\n",fname.c_str()); uiInstance->ui_rangeTable->loadData(fname); break;  // FILE CHOSEN
  		}	
  		break;
    	case RANGE_CLEAR:
    		uiInstance->clearRanges(true);
  		RangeTableCB(NULL, NULL);
    		break;
     	case RANGE_DELETE:
     		uiInstance->deleteRange();
     		RangeTableCB(NULL, NULL);
     		break;
  		RangeTableCB(NULL, NULL);
  	case RANGE_FIND:
  		InterfaceCCAPI::findAddresses();
  		break;
    	case RANGE_CANCEL:
    		InterfaceCCAPI::cancelFindAddresses();
    		break;		
  }
}

void rkCheatUI::SearchTypeChangeCB(Fl_Widget *w, void *data) {
  if (uiInstance->ui_searchType->isFuzzy())
  	uiInstance->ui_valueInputGroup->deactivate();
  else
  	uiInstance->ui_valueInputGroup->activate();
  
  if (uiInstance->canStartScan()) //I have a value entered or fuzzy
  {
  	if (uiInstance->m_inProgress)
  	{
  		uiInstance->ui_buttonNextScan->activate();
  		uiInstance->ui_buttonNewScan->activate();
  	}
  	else
  	{
  		uiInstance->ui_buttonNewScan->activate();
  		uiInstance->ui_buttonNextScan->deactivate();		
  	}
  }
  else //i have no value entered and not fuzzy
  {
  	if (uiInstance->m_inProgress)
  	{
  		uiInstance->ui_buttonNextScan->deactivate();
  		uiInstance->ui_buttonNewScan->activate();
  	}
  	else
  	{
  		uiInstance->ui_buttonNewScan->deactivate();
  		uiInstance->ui_buttonNextScan->deactivate();		
  	}
  }
}

void rkCheatUI::SearchValueChangeCB(Fl_Widget *w, void *data) {
  if (uiInstance->canStartScan()) //i have a value
    {
  			  if (uiInstance->m_inProgress)
  			  {
      			uiInstance->ui_buttonNewScan->activate();
  				uiInstance->ui_buttonNextScan->activate();
  			  }
  			  else
  			  {
      			uiInstance->ui_buttonNewScan->activate();
  				uiInstance->ui_buttonNextScan->deactivate();
  			  }
    }
    else
    {
  	  		  if (uiInstance->m_inProgress)
  			  {
      			uiInstance->ui_buttonNewScan->activate();
  				uiInstance->ui_buttonNextScan->deactivate();
  			  }
  			  else
  			  {
      			uiInstance->ui_buttonNewScan->deactivate();
  				uiInstance->ui_buttonNextScan->deactivate();
  			  }
    }
}

void rkCheatUI::SetHexCB(Fl_Widget *w, void *data) {
  int value = (int)((Fl_Button*)w)->value();
  uiInstance->ui_valueInput->setHex(value == 1);
}

void rkCheatUI::SetValueTypeCB(Fl_Widget *w, void *data) {
  int value = (int)((Fl_Menu_Button*)w)->mvalue()->user_data();
  uiInstance->ui_valueInput->setValueType(value);
}

void rkCheatUI::StartSearchButtonCB(Fl_Widget *w, void *data) {
  InterfaceCCAPI::startNewSearch();
}

void rkCheatUI::ContinueSearchCB(Fl_Widget *w, void *data) {
  InterfaceCCAPI::continueSearch();
}

void rkCheatUI::RangeInputCB(Fl_Widget *w, void *data) {
  string v1 = uiInstance->ui_addRangeInput_Start->value();
    	string v2 = uiInstance->ui_addRangeInput_End->value();
  	if (w == uiInstance->ui_addRangeButton) //we hit the add range button
  	{
    		unsigned int loc1 = stoul(v1, nullptr, 16);
    		unsigned int loc2 = stoul(v2, nullptr, 16);
  		uiInstance->ui_rangeTable->addEntry(loc1, loc2);
  	}
  	else
  	{
    		if (v1.empty() || v2.empty())
    		{
    			if (v1.empty())
    			{
  	  //			uiInstance->ui_addRangeInput_Start->color(fl_rgb_color(150,150,150));
  	  //			uiInstance->ui_addRangeInput_Start->value("00000000");
    			}
    			if (v2.empty())
    			{
  	  //			uiInstance->ui_addRangeInput_End->color(fl_rgb_color(150,150,150));
  	  //			uiInstance->ui_addRangeInput_End->value("00000000");
    			}
    			uiInstance->ui_addRangeButton->deactivate();
    			return;
    		}
    		unsigned int loc1 = stoul(v1, nullptr, 16);
    		unsigned int loc2 = stoul(v2, nullptr, 16);
    		if (loc2 <= loc1)
    		{
    			uiInstance->ui_addRangeButton->deactivate();
    			return;
    		}
    		uiInstance->ui_addRangeButton->activate();
  	}
}

void rkCheatUI::RangeTableCB(Fl_Widget *w, void *data) {
  if (uiInstance->canStartScan())
      		  uiInstance->ui_buttonNewScan->activate();
      	  else
      		  uiInstance->ui_buttonNewScan->deactivate();
}

void rkCheatUI::ResultTableButtonCB(Fl_Widget *w, void *data) {
  int command = (int)data;
  string fname;
  Fl_Native_File_Chooser fnfc;
  vector<AddressItem> items;
  switch (command)
  {
  case RESULT_TABLE_ADD:
    	items = uiInstance->ui_resultTable->getSelectedResults();
  	if (!items.empty())
  		uiInstance->ui_codeTable->addResults(items, InterfaceCCAPI::instance->getSearchValueType());
    	break;
  case RESULT_TABLE_DELETE:
    	uiInstance->ui_resultTable->deleteResults();
  	if (InterfaceCCAPI::instance)
  	{
  		unsigned long res = InterfaceCCAPI::instance->getNumberOfResults();
  		uiInstance->setNumberOfResultsString(to_string(res));
  	}
    	break;
      case RESULT_TABLE_REFRESH:
    	uiInstance->ui_resultTable->refreshResults();    
  	break;
  }
  #if 0
  	fnfc.title("Save Code Table");
      	fnfc.type(Fl_Native_File_Chooser::BROWSE_SAVE_FILE);
      	fnfc.filter("Code Tables\t*.ct");
      	fnfc.directory("/var/tmp");
      	switch ( fnfc.show() ) {
      		case -1: printf("ERROR: %s\n", fnfc.errmsg());    break;  // ERROR
      		case  1: printf("CANCEL\n");                      break;  // CANCEL
      		default: 
      		fname = fnfc.filename();
      		if (fnfc.filter_value() == 0)
      		{
      			if (fname.find(".ct", fname.size()-3) == string::npos)
      				fname += ".ct";
      		}
      		printf("PICKED: %s\n",fname.c_str()); uiInstance->ui_codeTable->saveData(fname); break;  // FILE CHOSEN
      	}
      	break;
      case CODE_TABLE_LOAD:
      	fnfc.title("Load Code Table");
      	fnfc.type(Fl_Native_File_Chooser::BROWSE_FILE);
      	fnfc.filter("Code Tables\t*.ct");
      	fnfc.directory("/var/tmp");
      	switch ( fnfc.show() ) {
      		case -1: printf("ERROR: %s\n", fnfc.errmsg());    break;  // ERROR
      		case  1: printf("CANCEL\n");                      break;  // CANCEL
      		default: 
      		fname = fnfc.filename();
      		printf("PICKED: %s\n",fname.c_str()); uiInstance->ui_codeTable->loadData(fname); break;  // FILE CHOSEN
      	}	
      	break;
  #endif
}

void rkCheatUI::CodeTableButtonCB(Fl_Widget *w, void *data) {
  int command = (int)data;
    string fname;
    Fl_Native_File_Chooser fnfc;
    switch (command)
    {
  	case CODE_TABLE_NEW:
  		uiInstance->ui_codeTable->newCode();
  		break;
  	case CODE_TABLE_DELETE:
  		uiInstance->ui_codeTable->deleteCodes();
  		break;
    	case CODE_TABLE_SAVE:
    		fnfc.title("Save Code Table");
    		fnfc.type(Fl_Native_File_Chooser::BROWSE_SAVE_FILE);
    		fnfc.filter("Code Tables\t*.ct");
    		fnfc.directory("/var/tmp");
    		switch ( fnfc.show() ) {
    		  case -1: printf("ERROR: %s\n", fnfc.errmsg());    break;  // ERROR
    		  case  1: printf("CANCEL\n");                      break;  // CANCEL
    		  default: 
    		  	fname = fnfc.filename();
    		  	if (fnfc.filter_value() == 0)
    		  	{
    				if (fname.find(".ct", fname.size()-3) == string::npos)
    					fname += ".ct";
    			}
    		  	printf("PICKED: %s\n",fname.c_str()); uiInstance->ui_codeTable->saveData(fname); break;  // FILE CHOSEN
    		}
    		break;
    	case CODE_TABLE_LOAD:
    		fnfc.title("Load Code Table");
    		fnfc.type(Fl_Native_File_Chooser::BROWSE_FILE);
    		fnfc.filter("Code Tables\t*.ct");
    		fnfc.directory("/var/tmp");
    		switch ( fnfc.show() ) {
    		  case -1: printf("ERROR: %s\n", fnfc.errmsg());    break;  // ERROR
    		  case  1: printf("CANCEL\n");                      break;  // CANCEL
    		  default: 
    		  	fname = fnfc.filename();
    		  	printf("PICKED: %s\n",fname.c_str()); uiInstance->ui_codeTable->loadData(fname); break;  // FILE CHOSEN
    		}	
    		break;
    }
}

void rkCheatUI::ConnectButtonCB(Fl_Widget *w, void *data) {
  if (InterfaceCCAPI::instance)
        {
      	  if ( ((Fl_Button*)w)->value() == 0 ) //disconnect
      	  {
        		InterfaceCCAPI::instance->disconnect();
        		uiInstance->setConnectStatus(INTERFACE_DISCONNECT);
        	  }
      	  else
    	  {
    		string ip = uiInstance->ui_ipInput->getIP();
    		uiInstance->ui_ipInput->deactivate();
      		InterfaceCCAPI::instance->connect(ip);
  			uiInstance->setConnectStatus(INTERFACE_CONNECTING);
    	  }
        }
}

void rkCheatUI::CanConnectCB(Fl_Widget *w, void *data) {
  bool valid = data;
    if (valid && uiInstance)
  	  uiInstance->ui_connectButton->activate();
    else if (!valid && uiInstance)
  	  uiInstance->ui_connectButton->deactivate();
}

rkCheatUI::rkCheatUI() {
  uiInstance = this;
  m_interface = 0;
  m_inProgress = false;
  { mainWindow = new rkWindow(1389, 817, "CCCheat");
    mainWindow->box(FL_FLAT_BOX);
    mainWindow->color(FL_BACKGROUND_COLOR);
    mainWindow->selection_color(FL_BACKGROUND_COLOR);
    mainWindow->labeltype(FL_NO_LABEL);
    mainWindow->labelfont(0);
    mainWindow->labelsize(14);
    mainWindow->labelcolor(FL_FOREGROUND_COLOR);
    mainWindow->user_data((void*)(this));
    mainWindow->align(Fl_Align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE));
    mainWindow->when(FL_WHEN_RELEASE);
    { searchGroup = new Fl_Group(10, 70, 380, 274, "Search");
      searchGroup->box(FL_BORDER_BOX);
      searchGroup->color(FL_DARK1);
      { ui_searchType = new SearchOperationChoice(104, 96, 281, 23, "Search Type:");
        ui_searchType->box(FL_FLAT_BOX);
        ui_searchType->down_box(FL_BORDER_BOX);
        ui_searchType->color(FL_BACKGROUND_COLOR);
        ui_searchType->selection_color(FL_SELECTION_COLOR);
        ui_searchType->labeltype(FL_NORMAL_LABEL);
        ui_searchType->labelfont(0);
        ui_searchType->labelsize(14);
        ui_searchType->labelcolor(FL_FOREGROUND_COLOR);
        ui_searchType->textsize(12);
        ui_searchType->callback((Fl_Callback*)SearchTypeChangeCB);
        ui_searchType->align(Fl_Align(FL_ALIGN_LEFT));
        ui_searchType->when(FL_WHEN_CHANGED);
      } // SearchOperationChoice* ui_searchType
      { ui_valueType = new Fl_Choice(95, 166, 113, 23, "Value Type:");
        ui_valueType->down_box(FL_BORDER_BOX);
        ui_valueType->callback((Fl_Callback*)SetValueTypeCB);
        ui_valueType->menu(menu_ui_valueType);
      } // Fl_Choice* ui_valueType
      { ui_buttonNewScan = new Fl_Button(40, 231, 80, 24, "New Scan");
        ui_buttonNewScan->callback((Fl_Callback*)StartSearchButtonCB);
        ui_buttonNewScan->deactivate();
      } // Fl_Button* ui_buttonNewScan
      { ui_buttonNextScan = new Fl_Button(170, 230, 80, 24, "Next Scan");
        ui_buttonNextScan->callback((Fl_Callback*)ContinueSearchCB);
        ui_buttonNextScan->deactivate();
      } // Fl_Button* ui_buttonNextScan
      { ui_valueInputGroup = new Fl_Group(15, 119, 259, 41);
        ui_valueInputGroup->align(Fl_Align(FL_ALIGN_LEFT));
        { ui_valueInput = new ValueInput(60, 131, 135, 24, "Value:");
          ui_valueInput->box(FL_DOWN_BOX);
          ui_valueInput->color(FL_BACKGROUND2_COLOR);
          ui_valueInput->selection_color(FL_SELECTION_COLOR);
          ui_valueInput->labeltype(FL_NORMAL_LABEL);
          ui_valueInput->labelfont(0);
          ui_valueInput->labelsize(14);
          ui_valueInput->labelcolor(FL_FOREGROUND_COLOR);
          ui_valueInput->callback((Fl_Callback*)SearchValueChangeCB);
          ui_valueInput->align(Fl_Align(FL_ALIGN_LEFT));
          ui_valueInput->when(FL_WHEN_CHANGED);
        } // ValueInput* ui_valueInput
        { ui_isHex = new Fl_Check_Button(210, 140, 64, 15, "Hex");
          ui_isHex->down_box(FL_DOWN_BOX);
          ui_isHex->callback((Fl_Callback*)SetHexCB);
        } // Fl_Check_Button* ui_isHex
        ui_valueInputGroup->end();
      } // Fl_Group* ui_valueInputGroup
      searchGroup->end();
    } // Fl_Group* searchGroup
    { ui_resultGroup = new Fl_Group(785, 70, 560, 274, "Results");
      ui_resultGroup->box(FL_BORDER_BOX);
      ui_resultGroup->color(FL_DARK1);
      { ui_resultTable = new ResultTable(790, 99, 423, 240);
        ui_resultTable->box(FL_THIN_DOWN_FRAME);
        ui_resultTable->color(FL_BACKGROUND_COLOR);
        ui_resultTable->selection_color((Fl_Color)6);
        ui_resultTable->labeltype(FL_NORMAL_LABEL);
        ui_resultTable->labelfont(0);
        ui_resultTable->labelsize(14);
        ui_resultTable->labelcolor(FL_FOREGROUND_COLOR);
        ui_resultTable->align(Fl_Align(FL_ALIGN_TOP));
        ui_resultTable->when(FL_WHEN_RELEASE);
        ui_resultTable->end();
      } // ResultTable* ui_resultTable
      { ui_numOfResults = new Fl_Box(920, 77, 140, 16);
      } // Fl_Box* ui_numOfResults
      { new Fl_Box(790, 77, 130, 16, "Number of Results:");
      } // Fl_Box* o
      { ui_resultBtnGroup = new Fl_Group(1225, 100, 115, 165);
        { ui_ButtonAddResult = new Fl_Button(1230, 100, 100, 30, "Add Result");
          ui_ButtonAddResult->callback((Fl_Callback*)ResultTableButtonCB, (void*)(RESULT_TABLE_ADD));
        } // Fl_Button* ui_ButtonAddResult
        { ui_ButtonDeleteResult = new Fl_Button(1230, 140, 100, 30, "Delete Result");
          ui_ButtonDeleteResult->callback((Fl_Callback*)ResultTableButtonCB, (void*)(RESULT_TABLE_DELETE));
        } // Fl_Button* ui_ButtonDeleteResult
        { ui_ButtonRefreshResult = new Fl_Button(1230, 180, 100, 30, "Refresh");
          ui_ButtonRefreshResult->callback((Fl_Callback*)ResultTableButtonCB, (void*)(RESULT_TABLE_REFRESH));
        } // Fl_Button* ui_ButtonRefreshResult
        ui_resultBtnGroup->end();
      } // Fl_Group* ui_resultBtnGroup
      ui_resultGroup->end();
    } // Fl_Group* ui_resultGroup
    { ui_rangeGroup = new Fl_Group(410, 70, 355, 275, "Range");
      ui_rangeGroup->box(FL_BORDER_BOX);
      ui_rangeGroup->color(FL_DARK1);
      { ui_rangeTable = new RangeTable(418, 75, 223, 215);
        ui_rangeTable->box(FL_THIN_UP_FRAME);
        ui_rangeTable->color(FL_BACKGROUND_COLOR);
        ui_rangeTable->selection_color((Fl_Color)6);
        ui_rangeTable->labeltype(FL_NORMAL_LABEL);
        ui_rangeTable->labelfont(0);
        ui_rangeTable->labelsize(14);
        ui_rangeTable->labelcolor(FL_FOREGROUND_COLOR);
        ui_rangeTable->callback((Fl_Callback*)RangeTableCB);
        ui_rangeTable->align(Fl_Align(FL_ALIGN_TOP));
        ui_rangeTable->when(FL_WHEN_RELEASE);
        ui_rangeTable->end();
      } // RangeTable* ui_rangeTable
      { ui_buttonFindRanges = new Fl_Button(652, 96, 100, 30, "Find Ranges");
        ui_buttonFindRanges->callback((Fl_Callback*)RangeButtonCB, (void*)(RANGE_FIND));
      } // Fl_Button* ui_buttonFindRanges
      { ui_buttonSaveRanges = new Fl_Button(652, 136, 100, 30, "Save Ranges");
        ui_buttonSaveRanges->callback((Fl_Callback*)RangeButtonCB, (void*)(RANGE_SAVE));
      } // Fl_Button* ui_buttonSaveRanges
      { ui_buttonLoadRanges = new Fl_Button(652, 176, 100, 30, "Load Ranges");
        ui_buttonLoadRanges->callback((Fl_Callback*)RangeButtonCB, (void*)(RANGE_LOAD));
      } // Fl_Button* ui_buttonLoadRanges
      { ui_buttonClearRanges = new Fl_Button(652, 216, 100, 30, "Clear Ranges");
        ui_buttonClearRanges->callback((Fl_Callback*)RangeButtonCB, (void*)(RANGE_CLEAR));
      } // Fl_Button* ui_buttonClearRanges
      { ui_addRangeGrp = new Fl_Group(410, 295, 350, 50);
        ui_addRangeGrp->color(FL_DARK1);
        { ui_addRangeInput_Start = new ValueInput(420, 308, 100, 24);
          ui_addRangeInput_Start->box(FL_DOWN_BOX);
          ui_addRangeInput_Start->color(FL_BACKGROUND2_COLOR);
          ui_addRangeInput_Start->selection_color(FL_SELECTION_COLOR);
          ui_addRangeInput_Start->labeltype(FL_NORMAL_LABEL);
          ui_addRangeInput_Start->labelfont(0);
          ui_addRangeInput_Start->labelsize(14);
          ui_addRangeInput_Start->labelcolor(FL_FOREGROUND_COLOR);
          ui_addRangeInput_Start->callback((Fl_Callback*)RangeInputCB);
          ui_addRangeInput_Start->align(Fl_Align(FL_ALIGN_LEFT));
          ui_addRangeInput_Start->when(FL_WHEN_CHANGED);
          ui_addRangeInput_Start->setHex(true);
          ui_addRangeInput_Start->maximum_size(8);
        } // ValueInput* ui_addRangeInput_Start
        { ui_addRangeInput_End = new ValueInput(540, 308, 100, 24);
          ui_addRangeInput_End->box(FL_DOWN_BOX);
          ui_addRangeInput_End->color(FL_BACKGROUND2_COLOR);
          ui_addRangeInput_End->selection_color(FL_SELECTION_COLOR);
          ui_addRangeInput_End->labeltype(FL_NORMAL_LABEL);
          ui_addRangeInput_End->labelfont(0);
          ui_addRangeInput_End->labelsize(14);
          ui_addRangeInput_End->labelcolor(FL_FOREGROUND_COLOR);
          ui_addRangeInput_End->callback((Fl_Callback*)RangeInputCB);
          ui_addRangeInput_End->align(Fl_Align(FL_ALIGN_LEFT));
          ui_addRangeInput_End->when(FL_WHEN_CHANGED);
          ui_addRangeInput_End->setHex(true);
          ui_addRangeInput_End->maximum_size(8);
        } // ValueInput* ui_addRangeInput_End
        { ui_addRangeButton = new Fl_Button(652, 305, 100, 30, "Add Range");
          ui_addRangeButton->callback((Fl_Callback*)RangeInputCB);
          ui_addRangeButton->deactivate();
        } // Fl_Button* ui_addRangeButton
        ui_addRangeGrp->end();
      } // Fl_Group* ui_addRangeGrp
      { ui_buttonDeleteRange = new Fl_Button(652, 255, 100, 30, "Delete Range");
        ui_buttonDeleteRange->callback((Fl_Callback*)RangeButtonCB, (void*)(RANGE_DELETE));
      } // Fl_Button* ui_buttonDeleteRange
      ui_rangeGroup->end();
    } // Fl_Group* ui_rangeGroup
    { ui_statusbar = new Fl_Group(1, 775, 1364, 35);
      ui_statusbar->box(FL_BORDER_BOX);
      { ui_opProgress = new Fl_Progress(10, 782, 1220, 20);
        ui_opProgress->minimum(0.0f);
        ui_opProgress->maximum(1.0f);
      } // Fl_Progress* ui_opProgress
      { ui_opStatus = new Fl_Box(1225, 784, 135, 16, "Ready");
      } // Fl_Box* ui_opStatus
      ui_statusbar->size(mainWindow->w()-12, 35);
      ui_statusbar->position(0, mainWindow->h() - ui_statusbar->h() - 12);
      ui_statusbar->end();
    } // Fl_Group* ui_statusbar
    { ui_codeGroup = new Fl_Group(114, 395, 1120, 360, "Codes");
      ui_codeGroup->box(FL_BORDER_BOX);
      ui_codeGroup->color(FL_DARK1);
      { ui_codeTable = new CodeTable(119, 425, 985, 325);
        ui_codeTable->box(FL_THIN_DOWN_FRAME);
        ui_codeTable->color(FL_DARK1);
        ui_codeTable->selection_color((Fl_Color)6);
        ui_codeTable->labeltype(FL_NO_LABEL);
        ui_codeTable->labelfont(0);
        ui_codeTable->labelsize(14);
        ui_codeTable->labelcolor(FL_FOREGROUND_COLOR);
        ui_codeTable->align(Fl_Align(FL_ALIGN_TOP));
        ui_codeTable->when(FL_WHEN_RELEASE);
        ui_codeTable->end();
      } // CodeTable* ui_codeTable
      { ui_ButtonNewCode = new Fl_Button(1124, 465, 100, 30, "New Code");
        ui_ButtonNewCode->callback((Fl_Callback*)CodeTableButtonCB, (void*)(CODE_TABLE_NEW));
      } // Fl_Button* ui_ButtonNewCode
      { ui_ButtonDeleteCode = new Fl_Button(1124, 511, 100, 30, "Delete Code");
        ui_ButtonDeleteCode->callback((Fl_Callback*)CodeTableButtonCB, (void*)(CODE_TABLE_DELETE));
      } // Fl_Button* ui_ButtonDeleteCode
      { ui_ButtonSaveCodes = new Fl_Button(1124, 558, 100, 30, "Save Codes");
        ui_ButtonSaveCodes->callback((Fl_Callback*)CodeTableButtonCB, (void*)(CODE_TABLE_SAVE));
      } // Fl_Button* ui_ButtonSaveCodes
      { ui_ButtonLoadCodes = new Fl_Button(1124, 605, 100, 30, "Load Codes");
        ui_ButtonLoadCodes->callback((Fl_Callback*)CodeTableButtonCB, (void*)(CODE_TABLE_LOAD));
      } // Fl_Button* ui_ButtonLoadCodes
      ui_codeGroup->end();
    } // Fl_Group* ui_codeGroup
    { ui_connectButton = new Fl_Light_Button(20, 20, 100, 30, "Connect");
      ui_connectButton->callback((Fl_Callback*)ConnectButtonCB);
      ui_connectButton->deactivate();
    } // Fl_Light_Button* ui_connectButton
    { ui_ipInput = new IPInput(135, 20, 255, 30);
      ui_ipInput->box(FL_NO_BOX);
      ui_ipInput->color(FL_BACKGROUND_COLOR);
      ui_ipInput->selection_color(FL_BACKGROUND_COLOR);
      ui_ipInput->labeltype(FL_NORMAL_LABEL);
      ui_ipInput->labelfont(0);
      ui_ipInput->labelsize(14);
      ui_ipInput->labelcolor(FL_FOREGROUND_COLOR);
      ui_ipInput->callback((Fl_Callback*)CanConnectCB);
      ui_ipInput->align(Fl_Align(FL_ALIGN_TOP));
      ui_ipInput->when(FL_WHEN_CHANGED);
      readIP();
      ui_ipInput->end();
    } // IPInput* ui_ipInput
    mainWindow->end();
  } // rkWindow* mainWindow
}

void rkCheatUI::setInterface(InterfaceCCAPI *iface) {
  m_interface = iface;
}

void rkCheatUI::clearRanges(bool reInit) {
  ui_rangeTable->clear();
  if (reInit)
  	ui_rangeTable->addEntry(0, 0xFFFFFFFF);
  	ui_rangeTable->clearSelection();
}

void rkCheatUI::deleteRange() {
  for (int i=ui_rangeTable->rows()-1; i>=0; i--)
  	{
  		if (ui_rangeTable->row_selected(i))
  		{
  			ui_rangeTable->deleteEntry(i);
  		}
  	}
  	ui_rangeTable->clearSelection();
}

void rkCheatUI::addRange(unsigned long begin, unsigned long end) {
  ui_rangeTable->addEntry(begin, end);
}

void rkCheatUI::setRangeProgress(float percent, string status, bool done) {
  static char stat[50];
  static char pc[20];
  ui_opProgress->value(percent);
  sprintf(pc, "%.1f%%", percent*100);
  ui_opProgress->label(pc);
  strncpy(stat, status.c_str(), 50);
  ui_opStatus->label(stat);
}

void rkCheatUI::findRangeStarted() {
  searchGroup->deactivate();
  ui_buttonSaveRanges->deactivate();
  ui_buttonLoadRanges->deactivate();
  ui_buttonClearRanges->deactivate();
  ui_buttonDeleteRange->deactivate();
  ui_addRangeGrp->deactivate();
  ui_buttonFindRanges->label("Cancel");
  ui_buttonFindRanges->user_data((void*)(RANGE_CANCEL));
}

void rkCheatUI::findRangeStopped() {
  searchGroup->activate();
  ui_buttonSaveRanges->activate();
  ui_buttonLoadRanges->activate();
  ui_buttonClearRanges->activate();
  ui_buttonDeleteRange->activate();
  ui_addRangeGrp->activate();
  ui_buttonFindRanges->label("Find Ranges");
  ui_buttonFindRanges->user_data((void*)(RANGE_FIND));
}

bool rkCheatUI::canStartScan() {
  if (ui_rangeTable->hasSelection())
  	{
  		if (ui_searchType->isFuzzy())//I don't care about the value
  			return true;
  		if (!string(ui_valueInput->value()).empty())
  			return true;
  	}
  	return false;
}

void rkCheatUI::searchStarted() {
  ui_rangeGroup->deactivate();
  ui_searchType->deactivate();
  ui_valueInputGroup->deactivate();
  ui_valueType->deactivate();
  ui_buttonNextScan->deactivate();
  ui_buttonNewScan->label("Cancel");
  ui_buttonNewScan->activate();
  ui_resultTable->setResultType((char)ui_valueType->mvalue()->user_data());
}

void rkCheatUI::searchStopped(char how) {
  if (how == SEARCH_STOPPED_PROPER)
  {
  	ui_rangeGroup->deactivate();
  	ui_valueType->deactivate();
  	ui_buttonNextScan->activate();
  	ui_buttonNewScan->label("Reset Scan");
  	m_inProgress = true;
  }
  else
  {
  	ui_numOfResults->label("");
  	ui_rangeGroup->activate();
  	ui_valueType->activate();
  	ui_buttonNextScan->deactivate();
  	if (how == SEARCH_STOPPED_NO_RESULTS)
  		ui_buttonNewScan->label("Reset Scan");
  	else
  		ui_buttonNewScan->label("New Scan");
  	m_inProgress = false;		
  }
  ui_searchType->activate();
  ui_valueInputGroup->activate();
  ui_buttonNewScan->activate();
  SearchTypeChangeCB(0,0);
}

void rkCheatUI::setSearchProgress(float percent, string status, bool done) {
  static char stat[50];
  static char pc[20];
  ui_opProgress->value(percent);
  sprintf(pc, "%.1f%%", percent*100);
  ui_opProgress->label(pc);
  strncpy(stat, status.c_str(), 50);
  ui_opStatus->label(stat);
}

void rkCheatUI::setNumberOfResultsString(string res) {
  static char stat[50];
  strncpy(stat, res.c_str(), 50);
  ui_numOfResults->label(stat);
}

void rkCheatUI::setConnectStatus(char status) {
  static char stat[50];
  if (status == INTERFACE_CONNECT_FAIL)
  {
  sprintf(stat, "Cannot Connect!");
  ui_opStatus->labelcolor(FL_RED);
  ui_opStatus->label(stat);
  searchGroup->deactivate();
  ui_rangeGroup->deactivate();
  ui_resultGroup->deactivate();
  ui_codeGroup->deactivate();
  ui_connectButton->clear();
  ui_ipInput->activate();
  }
  else if (status == INTERFACE_CONNECT_SUCCESS)
  {
  sprintf(stat, "Ready");
  ui_opStatus->labelcolor(FL_BLACK);
  ui_opStatus->label(stat);
  searchGroup->activate();
  ui_rangeGroup->activate();
  ui_resultGroup->activate();
  ui_codeGroup->activate();
  ui_ipInput->deactivate();
  ui_connectButton->selection_color(FL_GREEN);
  ui_connectButton->damage(FL_DAMAGE_ALL);
  storeIP();
  }
  else if (status == INTERFACE_DISCONNECT)
  {
  sprintf(stat, "Disconnected");
  ui_opStatus->labelcolor(FL_BLACK);
  ui_opStatus->label(stat);
  searchGroup->deactivate();
  ui_rangeGroup->deactivate();
  ui_resultGroup->deactivate();
  ui_codeGroup->deactivate();
  ui_connectButton->clear();
  ui_ipInput->activate();
  ui_ipInput->checkValid();
  }
  else if (status == INTERFACE_CONNECTING)
  {
  sprintf(stat, "Connecting");
  ui_opStatus->labelcolor(FL_BLACK);
  ui_opStatus->label(stat);
  searchGroup->deactivate();
  ui_rangeGroup->deactivate();
  ui_resultGroup->deactivate();
  ui_codeGroup->deactivate();
  ui_ipInput->deactivate();
  ui_connectButton->selection_color(FL_YELLOW);
  ui_connectButton->damage(FL_DAMAGE_ALL);
  }
}

void rkCheatUI::storeIP() {
  char buf[255];
  if (GetCurrentDir(buf, 255) != 0) //we can store the IP
  {
  	string dir = buf;
  	ofstream ipFile;
  	ipFile.open (dir+"/"+"ip.cfg");
  	ipFile << ui_ipInput->getIP();
  	ipFile.close();
  }
}

void rkCheatUI::readIP() {
  char buf[255];
  	if (GetCurrentDir(buf, 255) != 0) //we can store the IP
  	{
  		string dir = buf;
  		ifstream ipFile;
  		ipFile.open (dir+"/"+"ip.cfg");
  		if (ipFile)
  		{
  			string ip;
  			ipFile >> ip;
  			ui_ipInput->setIP(ip);
  			ipFile.close();
  		}
  	}
}
